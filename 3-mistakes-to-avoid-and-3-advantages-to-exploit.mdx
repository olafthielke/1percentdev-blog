---
title: '3 Mistakes To Avoid And 3 Advantages To Exploit'
date: '2024-01-17'
src: 'https://raw.githubusercontent.com/olafthielke/1percentdev-blog/main/images/3-mistakes-to-avoid-and-3-advantages-to-exploit.png'
tags: ['career advice', 'mistakes', 'advantages']
show: true
---

Just go faster.

Easier said than done.


As a junior developer, I wanted to get to senior dev quickly.

When I asked senior developers how to get there, they said I'd have to put in lots of work.


I did, and it worked. But was it efficient?

No.

Not even close.


With hindsight and 30 years of experience, I now clearly see my development career blunders and dead-ends.

You can avoid making the mistakes I did.


Today, I'm sharing 3 Mistakes to Avoid and 3 Advantages to Exploit in your software development career.

If I had known and followed this advice early on, I'd have learned twice as much in half the time and made senior developer years sooner.


## 3 Mistakes to Avoid
### Mistake 1: Only Learning New Technology

How could learning only the latest tech be a dumb move? How could you possibly fail?

Early in my career, I focussed almost exclusively on new tech: Sybase Database, ActiveX browser extensions, Microsoft's Silverlight, KnockoutJs.


Have you heard of any of these? Are they still around?

Answer: No, and no.


It's fun to learn new tech, but there is always a risk that
- it doesn't take off, and nobody uses it, or
- it takes off but has only a short lifetime.

Either way, you would have wasted much effort getting on top of the learning curve. And then you start all over with the next new tech.

There is no getting around it; you will need to learn much new technology. So, you don't want to avoid it either.

But it will aid your career immensely to focus on acquiring knowledge and skills that apply all the time[1]. More on this later.


### Mistake 2: Focusing on LeetCode

Solving algorithmic problems on LeetCode is excellent—if that is what you enjoy doing.

Just know you will seldom need to crack complex algorithmic problems in your career[2].

Most software development solves ordinary business problems, like reserving a seat, paying for an order, or managing user authentication.

Only on rare occasions will you be required to write an algorithm to determine whether a linked list is circular (or not).


LeetCode and other competitive coding websites mislead you in another way: They fool you into thinking you must complete coding tasks in record time.


Maintainability, understandability, scalability and efficiency of your code rank higher than the time it took you to write it.

Your fellow software engineers may initially be impressed with your time to complete, but that perception won't last if your code is a mess!


### Mistake 3: Too Much Focus on Coding

I love writing code. And coding is a critical skill for software engineers. So we had better be awesome at it.

Mid-career, I concentrated on getting proficient at programming, while ignoring other valuable skills that would have helped me advance faster:

- Effective Communication - Being able to clearly articulate complex problems and solutions to technical and non-technical stakeholders is a superpower. Applies to both verbal and written comms.
- Software Design & Architecture - Technical competence in structuring higher-level components like classes, packages, and entire subsystems is a must.
- Problem Solving - Being able to effectively troubleshoot and solve complex problems is a highly valued skill in software engineering.
- Teamwork and Collaboration - Software development is a team sport. Producing great code but not being able to work well in a team will hurt your career like nothing else. Play nicely with others.
- Business and User Needs - See how your work fits into the broader business goals. Understand what users want from your software and then deliver that.
- Psychology - Gaining a deeper understanding of human nature and how we humans operate will assist you in all walks of life, e.g. pay negotiations, marketing, etc. [3]

It takes more than a knack for programming to grow into a high-performing software engineer on a take-off career trajectory!


## 3 Advantages to Exploit

### Advantage 1: Learn Principles

Principles are rules, guidelines, and models of the world that work reliably. Seek these out. They are worth learning more than the latest tech fad.

Why?

Once you understand a principle, it will benefit your software development for the rest of your career. It doesn't get much better than that, right?

Many top performers credit their success in life to this simple, invaluable concept:


Billionaire investors Warren Buffett and his late partner Charlie Munger admitted they got rich by concentrating on fundamentals that never change:
- What makes a great business, and
- What makes for a low-risk investment, and
- Human nature

Software development has its share of invariant principles. You will gain much career advantage from learning and understanding the following[4]:

- Clean Code - writing easy-to-understand, maintainable functions
- The SOLID Principles - how to design classes and modules
- The Component Principles - how to package units of deployment
- Software Architecture - how to compose entire systems
- Unit Testing/TDD - building reliable software
- CI/CD - Deploying work incrementally
- Fault tolerance / Observability - fast production feedback loops​

### Advantage 2: Learn By Teaching
It's uncanny, but it works.

Teach what you know.

By teaching others, you'll learn more and faster, too.

It sounds unbelievable that you will learn more by teaching material *you already know*. Yet, there is no arguing with the results.


You may not know much, yet there will be someone who doesn't know what you know.

The knowledge you have does not need to be earth-shattering to be worth comprehending and teaching.

Do you know a few handy tricks in Visual Studio Code? Great! Teach those to someone.


Here is a game-changing level-up workflow:

1. **Learn** something,
2. **Teach** it to others, which
3. **Reinforce**s the material in your mind, but also
4. **Expose**s unanswered questions, then
5. **Find** the answers to the questions, and
6. finally, back to 1.​

#### Furthermore:
- **Offer Help**: Others will appreciate it and will reciprocate when you need assistance.
- **Gateway to Leadership**: Teaching, mentoring and helping others gets the team unstuck and performing to its potential. You're demonstrating engineering leadership!
- **Be Friendly**: Being seen as friendly makes you deserve goodness flowing back your way, too. Let's face it: nobody wants to work with Grumpy or Grouchy.

### Advantage 3: Build Real Systems
As a software engineer, you'll be building actual systems real people use, so you should practice building those.

I recommend <a href="https://www.linkedin.com/newsletters/coding-challenges-7040206098607308801/" target="_blank">John Crickett's Coding Challenges newsletter on LinkedIn</a>.


If you find those too challenging, scale it back to writing a To-Do or a pantry-tracking app. And if this app solves a problem in your life, then you win twice!


## Conclusion
Let's recap the points.

### 3 Mistakes to Avoid
1. Only Learning New Technology - While learning new tech is important, understanding timeless principles is even better.
2. Focusing on LeetCode - Competitive programming does not represent what you do at work, so why do it?
3. Too Much Focus on Coding - Software engineering is more than coding, and developing skills in other areas is a must for career success.


### 3 Advantages to Exploit
1. Learn Principles - What are the invariants in software engineering? Which rules, guidelines and techniques work all the time? Learn those, and you'll reap the rewards for the rest of your career.
2. Learn By Teaching - Teaching requires a deeper understanding than merely knowing something for yourself. Grow faster by teaching.
3. Build Real Systems - This is what you're building at work, so it makes sense to practice writing actual systems.


Some paths get you to master software engineer faster than others.

Learn from the mistakes other people have already made—like me.

Also, learn from the actions that work reliably and produce advantages for those who use them.


Please remember that you'll still make mistakes; we all do.

Yet, with some forethought, you'll advance faster than you might have if you could only learn through personal experience.


##### Footnotes:
1. Or almost all the time.
2. Some specialist engineering careers, i.e. writing operating system kernels, require deep algorithmic knowledge.
3. I recommend 'Influence: Science and Practice' by Robert Cialdini or Daniel Kahneman's 'Thinking Fast and Slow'.
4. It's not an exhaustive list. E.g. learning a new programming language from time to time is a productive activity.